
/////////////////////////////////////////// MDArray.h //////////////////////////////////////
#pragma once

#include <cstdint>
#include <cstring>
#include <exception>

// 2D Array
template<typename DATA>
class TwoDArray
{
public:
	TwoDArray(int32_t x, int32_t y)
	{
		mDataBuf = new DATA[x * y];
		memset(mDataBuf, 0, x * y);
		mY = y;
		mX = x;
	}

	~TwoDArray()
	{
		if (mDataBuf)
		{
			delete[] mDataBuf;
		}
	}

	DATA& operator()(int32_t x, int32_t y)
	{
		if (x > mX || y > mY)
		{
			throw std::exception("over size!");
		}
		return mDataBuf[mX * y + x];
	}

	void resize(int32_t x, int32_t y)
	{
		if (mDataBuf)
		{
			delete[] mDataBuf;
		}
		mDataBuf = new DATA[x * y];
		memset(mDataBuf, 0, x * y);
		mY = y;
		mX = x;
	}

private:

private:
	DATA*	mDataBuf;
	int32_t	mY;
	int32_t	mX;
};

// 3D Array
template<typename DATA>
class ThreeDArray
{
public:
	ThreeDArray(int32_t x, int32_t y, int32_t z)
	{
		mDataBuf = new DATA[x * y * z];
		memset(mDataBuf, 0, x * y * z);
		mY = y;
		mX = x;
		mZ = z;
	}

	~ThreeDArray()
	{
		if (mDataBuf)
		{
			delete[] mDataBuf;
		}
	}

	DATA& operator()(int32_t x, int32_t y, int32_t z)
	{
		if (x > mX || y > mY || z > mZ)
		{
			throw std::exception("over size!");
		}
		return mDataBuf[mX * mY * z + mX * y + x];
	}

	void resize(int32_t x, int32_t y, int32_t z)
	{
		if (mDataBuf)
		{
			delete[] mDataBuf;
		}
		mDataBuf = new DATA[x * y * z];
		memset(mDataBuf, 0, x * y * z);
		mY = y;
		mX = x;
		mZ = z;
	}

private:

private:
	DATA* mDataBuf;
	int32_t	mY;
	int32_t	mX;
	int32_t	mZ;
};

/////////////////////////////////////////// PathFinder.h //////////////////////////////////////
#pragma once

#include <vector>

#include "MDArray.h"

enum PositonStatus
{
	PS_FREE = 0,	// 未遍历状态
	PS_CHECK = 1,	// 已遍历但未加入路径
	PS_CONFIRM = 2,	// 已经确认加入路径
};

struct Position2D
{
	Position2D() : x(-1), y(-1) {}
	Position2D(int px, int py) : x(px), y(py) {}
	int x;
	int y;
};

struct PositionNode
{
	PositionNode() : status(PS_FREE), access(1) {}
	Position2D pos;
	int status;
	int access;
	Position2D parent;
};

#define PositionNodeEqual(nodeA, nodeB) \
	(nodeA.pos.x == nodeB.pos.x && nodeA.pos.y == nodeB.pos.y)
#define PositionNodeUnequal(nodeA, nodeB) \
	(nodeA.pos.x != nodeB.pos.x || nodeA.pos.y != nodeB.pos.y)
#define SetParentPosition(nodeA, nodeB) \
	do { if(nodeA.parent.x == -1 && nodeA.parent.y == -1) nodeA.parent = nodeB.pos; }while(0)
#define DIRECTION_SIZE 4

class PathFinder
{
public:
	PathFinder() : map(TwoDArray<PositionNode>(1, 1)), xSize(1), ySize(1) {}
	void setStartPos(int x, int y);
	void setTargetPos(int x, int y);
	void setMapSize(int x, int y);
	void getPath(std::vector<PositionNode>& outputPath);
	TwoDArray<PositionNode>& getMap();

private:
	void initDirection();
	bool findNext(PositionNode& current, int pathSize, PositionNode& next);
	double checkPosition(PositionNode& current, int cX, int cY, int pathSize);
	void checkPath(std::vector<PositionNode>& confirmPostions, std::vector<PositionNode>& outputPath);
	void printMapDebug();

private:
	PositionNode startPostion;
	PositionNode targetPostion;
	TwoDArray<PositionNode> map;
	int xSize;
	int ySize;
	Position2D directionArray[DIRECTION_SIZE];
};

/////////////////////////////////////////// PathFinder.h //////////////////////////////////////
#include "PathFinder.h"

#include <cmath>
#include <iostream>
#include <Windows.h>

void PathFinder::setStartPos(int x, int y)
{
	startPostion.pos.x = x;
	startPostion.pos.y = y;
	startPostion.status = PS_CONFIRM;
}

void PathFinder::setTargetPos(int x, int y)
{
	targetPostion.pos.x = x;
	targetPostion.pos.y = y;
	targetPostion.status = PS_FREE;
}

void PathFinder::setMapSize(int x, int y)
{
	map.resize(x, y);
	xSize = x;
	ySize = y;
	for (int i = 0; i < x; ++i)
	{
		for (int j = 0; j < y; ++j)
		{
			PositionNode& node = map(i, j);
			node.pos.x = i;
			node.pos.y = j;
			node.access = 1;
			node.status = PS_FREE;
			node.parent.x = -1;
			node.parent.y = -1;
		}
	}
}

void PathFinder::getPath(std::vector<PositionNode>& outputPath)
{
	initDirection();
	printMapDebug();

	std::vector<PositionNode> confirmPostions;
	PositionNode position = startPostion;
	confirmPostions.push_back(position);
	while (PositionNodeUnequal(position, targetPostion))
	{
		std::cout << "current position: " << position.pos.x << ", " << position.pos.y << "\n";
		Sleep(1500);
		PositionNode next;
		if (findNext(position, confirmPostions.size(), next))
		{
			std::cout << "next position" << next.pos.x << ", " << next.pos.y << "\n";
			PositionNode& nextInMap = map(next.pos.x, next.pos.y);
			nextInMap.status = PS_CONFIRM;
			if (PositionNodeUnequal(nextInMap, startPostion))
			{
				SetParentPosition(nextInMap, position);
			}
			
			position = nextInMap;
			confirmPostions.push_back(position);
		}
		else
		{
			confirmPostions.pop_back();
			position = confirmPostions.back();
		}
	}
	checkPath(confirmPostions, outputPath);
}

TwoDArray<PositionNode>& PathFinder::getMap()
{
	return map;
}

void PathFinder::initDirection()
{
	// 左
	directionArray[0].x = -1;
	directionArray[0].y = 0;

	// 右
	directionArray[1].x = 1;
	directionArray[1].y = 0;

	// 上
	directionArray[2].x = 0;
	directionArray[2].y = -1;

	// 下
	directionArray[3].x = 0;
	directionArray[3].y = 1;
}

bool PathFinder::findNext(PositionNode& current, int pathSize, PositionNode& next)
{
	bool findNextSucc = false;
	double minLength = 99999999999.0;	// 各顶点的预期路径总长
	// 分别获取上下左右四个顶点
	for (int i = 0; i < DIRECTION_SIZE; ++i)
	{
		int towardX = current.pos.x + directionArray[i].x;
		int towardY = current.pos.y + directionArray[i].y;
		if (towardX >= 0 && towardX < xSize &&
			towardY >= 0 && towardY < ySize &&
			map(towardX, towardY).access != 0)
		{
			double length = checkPosition(current, towardX, towardY, pathSize);
			std::cout << "length:" << length << "\n";
			if (length < minLength && length > 0)
			{
				minLength = length;
				next.pos.x = towardX;
				next.pos.y = towardY;
				findNextSucc = true;
			}
		}
	}
	return findNextSucc;
}

double PathFinder::checkPosition(PositionNode& current, int cX, int cY, int pathSize)
{
	// 节点是否未被遍历
	PositionNode& posNode = map(cX, cY);
	if (posNode.status != PS_CONFIRM)
	{
		if (posNode.status == PS_FREE)
		{
			posNode.status = PS_CHECK;
			if (PositionNodeUnequal(posNode, startPostion))
			{
				SetParentPosition(posNode, current);
			}
		}

		// 计算预期剩余路径
		return pathSize + sqrt((cX - targetPostion.pos.x) * (cX - targetPostion.pos.x) +
			(cY - targetPostion.pos.y) * (cY - targetPostion.pos.y));
	}
	else
	{
		return -1;
	}
}

void PathFinder::checkPath(std::vector<PositionNode>& confirmPostions, std::vector<PositionNode>& outputPath)
{
	PositionNode position = confirmPostions.back();
	outputPath.push_back(position);
	while (PositionNodeUnequal(position, startPostion))
	{
		Position2D& parent2D = position.parent;
		if (parent2D.x == -1 || parent2D.y == -1)
		{
			std::cout << "Error parent node\n";
			outputPath.clear();
			return;
		}
		position = map(parent2D.x, parent2D.y);
		outputPath.push_back(position);
	}
}

void PathFinder::printMapDebug()
{
	for (int j = 0; j < xSize; ++j)
	{
		for (int i = 0; i < ySize; ++i)
		{
			std::cout << map(i, j).access << "  ";
		}
		std::cout << "\n";
	}
}
